## 汇编语言(1)

### 重点一：数据的储存

AX为十六位寄存器，当计算的结果的最高位超出了寄存器最多存储的位数时，超出的最高位要舍弃。

* 8086有20位地址总线，可传送20位地址，寻址能力为1M（2^20 B = 1024 KB）
* 8086内部为16位结构，它只能传送16位的地址，表现的寻址能力为（2^16 B=64 KB）

**8086CPU采用了一种在内部两个16位的地址合成一个20位的物理地址**

### 重点二：物理地址

物理地址（20位）由 段地址（16位）与偏移地址（16位）组成

物理地址经CPU的20位地址总线传送到内存中

### 重点三：地址加法器

物理地址（20位） = 段地址（16位）* 16  + 偏移地址（16位）

【段地址 * 16 】相当于将段地址表示的十六进制数左移一位，再加上偏移地址，最终得到的数值为20位的物理地址。

![image-20211127172720877](C:\Users\fjq\AppData\Roaming\Typora\typora-user-images\image-20211127172720877.png)

 ### 重点四：段地址 * 16引发的讨论

1. 一个数据的二进制形式左移一位，相当于该数据乘以2
2. 一个数据的二进制形式左移N位，相当于该数据乘以2的N次方
3. 地址加法器如何完成段地址器乘16的运算？
   * 以二进制形式存放的段地址左移4位

### 重点五：段的理解

* 段并不是由内存划分，而是由CPU来规定。
* 在编程时根据需要，将若干地址连续的存储单元看作一个段，用段地址*16定位段的起始地址（基础地址），用偏移地址定位段内的存储单元。

段地址*16必然是16的倍数，因此一个短的起始地址也一定是16的倍数。

偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度为64K，一个段的最大长度取决于偏移地址的位数。

### 重点六：内存单元小结

CPU访问内存时，必须向内存提供内存的物理地址。

CPU可以用不同的段地址与不同的偏移地址来形成相同的物理地址。

* “数据在21F60H内存单元中”对于80X86CPU的两种表述：
  1. 数据再内存为2000:1F60单元中（规定段地址取2000）
  2. 数据存在内存为2000段中的1F60H单元中

### 重点七：段寄存器

段寄存器就是提供段地址的，四个段寄存器分别为CS,DS,SS,ES

当8086CPU访问内存时，由这四个寄存器提供内存单元的段地址。

### IP与CS寄存器

CS和IP是8086CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址，其中CS为代码段寄存器，IP为指令指针寄存器，且IP寄存器不是段寄存器。

CS存放指令的段地址，IP存放指令的偏移地址。

想要修改CS或IP寄存器不能使用MOV指令，需用转移指令（JMP），JMP指令格式：

```
JMP 段地址（CS）:偏移地址（IP）
```

若想仅改变IP内容则：

JMP 某一合法寄存器

```
JMP AX (类似于MOV IP,ax)
```

功能：用寄存器内容修改IP 内容



