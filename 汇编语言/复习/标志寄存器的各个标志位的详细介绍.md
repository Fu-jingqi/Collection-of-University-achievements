## 标志寄存器的各个标志位的详细介绍

### 1. 标志寄存器作用

* 用来为CPU执行相关指令提供行为依据
* 用来存储相关指令的某些执行结果
* 用来控制CPU的相关工作方式

### 2. 各个标志位介绍

#### <font color = #70DB93>1. 进位标志位CF</font>

CF标志：进位标志位（无符号数）

flag的第0位是CF，进位标志位。一般情况下，在进行**无符号数运算**时，它记录了运算结果的最高有效位向更高位的**进位值**，或者从最高位的**借位值**。

<font color = red>进位举例：</font>

```assembly
mov al,98H
add al,al	;执行之后，al的值变为30H，CF=1；此时CF记录了最高有效位向更高位的进位值。
add al,al	;执行之后，al的值变为60H，CF=0；此时CF记录了最高有效位向更高位的进位值。
```

<font color = red>借位举例：</font>

```assembly
mov al,97H
sub al,98H	;执行之后，al的值变为FFH，CF=1；此时CF记录了向更高位的借位值。
sub al,al	;执行之后，al的值变为0，CF=0；此时CF记录了向更高位的借位值。
```

**相关操作指令：**

* **CLC指令：**将CF置为0。

* **STC指令：**将CF置为1。

* **CMC指令：**原来是0变为1，原来是1变为0。

#### <font color = #70DB93>2. 溢出标志位OF</font>

OF标志：溢出标志位（仅当考虑有符号数，才考虑OF标志）

flag的第11位是OF，溢出标记位；一般情况下，OF记录了有符号数运算的结果是否发生了溢出；如果发生了溢出，则OF=1；如果没有，则OF=0。

```assembly
mov al,0F0H
add al,88H
```

<font color = orange>指令执行之后，CF=1，OF=1。如果把该运算看作无符号数运算，则0F0H+88H产生了进位，故CF=1；如果把该运算看作有符号数运算，则0F0H+88H发生溢出，OF=1。</font>

```assembly
mov al,0F0H
add al,78H
```

<font color = orange>指令执行之后，CF=1，OF=0。如果把该运算看作无符号数运算，则0F0H+78H产生了进位，故CF=1；如果把该运算看作有符号数运算，则0F0H+78H不发生溢出，OF=0。</font>

**CF和OF之间的区别：CF是针对于无符号数运算，OF位是针对于有符号数运算。**

CF和OF所表示的进位和溢出，是分别对于无符号数和有符号数运算而言的，彼此之间没有任何的关系。

#### <font color = #70DB93>3. 符号标志位SF</font>

SF位：符号标志位（仅当考虑有符号数，才考虑SF标志）

<font color = red>在计算机里面，通常使用补码来表示有符号数据。</font>计算机的一个数据既可以看作有符号数，亦可以看作无符号数。譬如：

0000 0001B，可以看作为无符号数1，也可看做有符号数+1。

1000 0001B，可以看作为无符号数129，也可以看作有符号数-127。

```assembly
mov al，1000 0001B
add al，1
```

对于该运算，如果你把它看作无符号数的运算，那么就是129+1=130（1000 0010B）；也可以将其看作有符号数的运算，那么就是-127+1=-126（1000 0010B）。

**SF标志**，就是8086CPU对于有符号运算结果的一种记录，它记录了运算结果的正负。无论你把运算看作有符号运算还是无符号运算，SF的值都会改变，当你看作有符号运算时，它是有意义的；当你看作无符号运算时它是无意义的！

```assembly
mov al,1000 0001B
add al,1
```

运算结果为1000 0010B，SF=1；如果你把这个运算看作有符号数运算，那么结果为负。

```assembly
mov al,1000 0001B
add al,0111 1111B
```

运算结果是0，SF=1；如果你把这个运算看作有符号数运算，那么结果为正。

它记录着相关指令执行后其结果是否为负；如果结果为负，则SF=1；如果结果非负，则SF=0。

#### <font color = #70DB93>4. 奇偶标志位PF</font>

它记录着相关指令执行之后，其结果的所有bit位中1的个数是否为偶数；如果1的个数为偶数，则PF=1，如果1的个数为奇数，则PF=0。

**例如：**

```assembly
mov al,1
add al,10
```

执行之后，结果是0000 1011B；其中有3个1；因此PF=0。

#### <font color = #70DB93>5. 零标志位ZF</font>

flag寄存器的第6位是ZF，零标志位；它记录着相关指令执行之后，其结果是否为零；如果结果为零，那么ZF=1，如果结果不为零，那么ZF=0。

**例如：**

```assembly
mov ax,1
sub ax,1
```

执行之后，结果为零，则ZF=1。

```assembly
mov ax,2
sub ax,1
```

执行之后，结果为1，则ZF=0。

### 3. 常用指令对标志位的影响

1. ADD指令主要对CF，ZF，OF，SF有影响
2. ADC指令主要对CF，ZF，OF，SF有影响
3. INC指令主要对AF，PF，ZF，OF，SF有影响，对CF无影响
4. SUB指令主要对CF，ZF，OF，SF有影响
5. SBB指令主要对CF，ZF，OF，SF有影响
6. DEC指令主要对AF，PF，ZF，OF，SF有影响，对CF无影响
7. MUL乘法指令只影响标志位CF和OF
8. 无符号数除法 DIV和带符号数除法 IDIV指令对标志位的影响：不影响条件码。  

```assembly
					;bx 可以做为索引寄存器
m dw 1,2,3,4,5,6,7,8,9,10
lea bx,m  	   		; 把m的首地址放入bx，即把bx当作索引，C语言中的指针概念即来源于此
　　　　　　			; 如果你学过C语言的话
mov byte ptr al, [bx]; 读取1个字节的数据到al中.[bx]是寄存器寻址，即相当于
           	; C语言中的 char a = *(char*)p;这类用法。
           	; byte ptr即指明操作类型是db类型。
           	; 同理，[bx+1]即指向了数据中下一个字节，对m这种dw类型的数据来说，
           	; 即相当于指向了[bx]对应的字数据的高位字节
			;比如：假如bx指向第1个字1, 1在内存中占2个字节01 00 (低位在前，高位在后,则:
mov al, byte ptr [bx] ;把低位01 送入al
mov ah, byte ptr [bx+1] ;把高位00状入ah
```



